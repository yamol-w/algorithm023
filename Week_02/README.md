学习笔记

哈希表(Hash Table)
	也叫散列表。
	通过关键码值映射到表中的一个位置，加快查询速度。这个映射的函数就是哈希函数。
	这里的位置其实是它的下标（index）。
	现实工程中的应用：电话号码簿；用户信息表；缓冲（LRU Cache）；键值对存储（Redis）
	时间复杂度：查询和删除大部分情况下是O(1)；最坏的情况就是hash table 整个size 太小，会变成链表结构，这时候时间复杂度为O(n)，或者选取hash函数不当。

	Map：
		key=>value 对，key 不重复

	Set(集合):
		不重复元素的集合。
		很多时候只是一个抽象的接口（interface）

树（Tree）

	知识点回顾：
		单链表：有头和尾，next指针不断往后指，
			 缺点：查询太慢，要O(n) 的时间复杂度
			 优化思想：升维
		双链表：
		跳表：

	树和图最关键的区别：有没有环。

	数节点定义代码：
		Java:
		public class TreeNode {
			public int val;
			public TreeNode left, right;

			public TreeNode(int val) {
				this.val = val;
				this.left = null;
				this.right = null;
			}
		}

		Python:
		class TreeNode:
			def __int__(self,val):
				self.val = null
				self.left, self.right = None, None

	二叉树遍历：
		1. 前序（Pre-order）: 根 - 左 - 右
		2. 中序（In-order）: 左 - 根 - 右
		3. 后序（Post-order）: 左 - 右 - 根

	二叉树的遍历：要拥抱递归。

	二叉搜索树
		也称二叉排序树，有序二叉树，排序二叉树，是指一棵空树具有以下性质的二叉树

		1. 左子树上所有节点的值均小于其根节点的值；
		2. 右子树上所有节点的值均大于其根节点的值；
		3. 以此类推：左、右子树也分别为二叉搜索树（重复性）

		*中序遍历->升序遍历

		查询 和 插入 时间复杂度均为 logN（加速了）

堆(Heap)
	可以迅速找到一堆数中最大值或最小值的数据结构。

	大顶堆(大根堆)：根节点最大的堆。
	小顶堆(小根堆)：根节点最小的堆。

	常见堆：二叉堆、斐波那契堆

	时间复杂度：
		find-max：O(1)
		delete-max：O(logN)
		insert：O(logN) 或 O(1)

	二叉堆的性质：
		通过完全二叉树来实现（注意：不是二叉搜索树）

		完全二叉树：它的根和每一级节点都是满的；除了最下面一层叶子可能不满之外。

		二叉堆（大顶）满足下列性质：
			1. 是一棵完全树
			2. 树中 任意 节点值总是 大于等于 其子节点值。

	二叉堆实现细节：
		1. 二叉堆一般都通过 “数组”	来实现
		2. 假设 “第一个元素” 的索引在数组中为 0 的话，则父节点和子节点的关系如下：
			(1) 索引为 i 的左孩子索引为 (2*i+1)
			(2) 索引为 i 的右孩子索引为 (2*i+2)
			(3) 索引为 i 的父节点索引为 floor((i-1)/2)

	插入操作（insert）：
		1. 新元素一律先插到堆的尾部
		2. 依次向上调整整个堆的结构（一直到根即可）
	
	删除堆顶操作（O(logN)）：
		1. 将堆尾元素替换到顶部（即堆顶被替换删除掉）
		2. 依次从根部向下调整整个堆的结构（一直到堆尾即可）




学习心得：
	本周的课程学习起来有些吃力，可能是语言的特性所致，PHP对Hash Table等这些数据结构较少。只能通过做题和看其他语言的题解来慢慢理解。








